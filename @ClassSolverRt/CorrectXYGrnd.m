function [mu_xy_corr, sigma_xy_corr] = CorrectXYGrnd( this, mu_x, sigma_x, ...
    mu_y, sigma_y, mu_z, sigma_z, jacobian_z )
%FUNCCORRGRNDPL: correct vec_xy from virtual measurement z
% x: 3by1 ground plane norm vector in camera frame
% y: 3by1 pt3d_m_c1-pt3d_m_c2, feature displacement in camera frame
% z: 1by1 virtual measurements, z = -J*[dx;dy]+f(mu_x, mu_y) = 0.5*H*[dx;dy]^2

mu_xy = [mu_x; mu_y];
sigma_xy = blkdiag(sigma_x, sigma_y);

%% constraint value with mean
f_mu_1 = mu_x.'*mu_y;
f_mu_2 = mu_x.'*mu_x - 1;
f_mu = [f_mu_1; f_mu_2];

% generate information matrix omega
omega_1 = inv(sigma_xy);
omega_2 = jacobian_z.'*inv(sigma_z)*jacobian_z;
xi_1 = zeros(6,1);
xi_2 = ((-f_mu-mu_z).'*inv(sigma_z)*jacobian_z).';

omega_dxy_corr = omega_1+omega_2;
xi_dxy_corr = xi_1+xi_2;

sigma_dxy_corr = inv(omega_dxy_corr);
mu_dxy_corr = sigma_dxy_corr*xi_dxy_corr;

mu_xy_corr = mu_dxy_corr + mu_xy;
sigma_xy_corr = sigma_dxy_corr;

%% propagation
% additional step, represent the error generated by linearization around
% different point.

dist_dxy = norm(mu_dxy_corr(1:3));
if dist_dxy > 0.05
    sigma_dx = 0.05*dist_dxy*eye(3);
    sigma_xy_corr(1:3,1:3) = sigma_xy_corr(1:3,1:3) + sigma_dx;
end

end

